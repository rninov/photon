From a29c49bd858dc3a1b76fcdd1a0662eefb8cbac02 Mon Sep 17 00:00:00 2001
From: Satya Naga Rajesh <svasamsetty@vmware.com>
Date: Tue, 8 Jun 2021 16:16:58 +0530
Subject: [PATCH] openssl 3.0.0 support

---
 src/main.cc                        |    2 +
 src/security/PeerOptions.cc        |   20 +-
 src/security/ServerOptions.cc      |    5 +
 src/security/ServerOptions.cc.orig |  493 ++++++++++
 src/ssl/gadgets.cc                 |   40 +-
 src/ssl/gadgets.h                  |    8 +-
 src/ssl/support.cc                 |    6 +-
 src/ssl/support.cc.orig            | 1333 ++++++++++++++++++++++++++++
 8 files changed, 1864 insertions(+), 43 deletions(-)
 create mode 100644 src/security/ServerOptions.cc.orig
 create mode 100644 src/ssl/support.cc.orig

diff --git a/src/main.cc b/src/main.cc
index 4b3988e..48e4777 100644
--- a/src/main.cc
+++ b/src/main.cc
@@ -678,7 +678,9 @@ mainHandleCommandLineOption(const int optId, const char *optValue)
             printf("%s\n",SQUID_BUILD_INFO);
 #if USE_OPENSSL
         printf("\nThis binary uses %s. ", OpenSSL_version(OPENSSL_VERSION));
+#if OPENSSL_VERSION_MAJOR < 3
         printf("For legal restrictions on distribution see https://www.openssl.org/source/license.html\n\n");
+#endif
 #endif
         printf( "configure options: %s\n", SQUID_CONFIGURE_OPTIONS);
 
diff --git a/src/security/PeerOptions.cc b/src/security/PeerOptions.cc
index 7088e36..26ac3b4 100644
--- a/src/security/PeerOptions.cc
+++ b/src/security/PeerOptions.cc
@@ -327,12 +327,12 @@ static struct ssl_option {
         "TLS_BLOCK_PADDING_BUG", SSL_OP_TLS_BLOCK_PADDING_BUG
     },
 #endif
-#if SSL_OP_TLS_ROLLBACK_BUG
+#if (OPENSSL_VERSION_NUMBER >= 0x10101000L)
     {
         "TLS_ROLLBACK_BUG", SSL_OP_TLS_ROLLBACK_BUG
     },
 #endif
-#if SSL_OP_ALL
+#if (OPENSSL_VERSION_NUMBER >= 0x10101000L)
     {
         "ALL", (long)SSL_OP_ALL
     },
@@ -367,7 +367,7 @@ static struct ssl_option {
         "NON_EXPORT_FIRST", SSL_OP_NON_EXPORT_FIRST
     },
 #endif
-#if SSL_OP_CIPHER_SERVER_PREFERENCE
+#if (OPENSSL_VERSION_NUMBER >= 0x10101000L)
     {
         "CIPHER_SERVER_PREFERENCE", SSL_OP_CIPHER_SERVER_PREFERENCE
     },
@@ -377,45 +377,45 @@ static struct ssl_option {
         "NETSCAPE_DEMO_CIPHER_CHANGE_BUG", SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG
     },
 #endif
-#if SSL_OP_NO_SSLv3
+#if (OPENSSL_VERSION_NUMBER >= 0x10101000L)
     {
         "NO_SSLv3", SSL_OP_NO_SSLv3
     },
 #endif
-#if SSL_OP_NO_TLSv1
+#if (OPENSSL_VERSION_NUMBER >= 0x10101000L)
     {
         "NO_TLSv1", SSL_OP_NO_TLSv1
     },
 #else
     { "NO_TLSv1", 0 },
 #endif
-#if SSL_OP_NO_TLSv1_1
+#if (OPENSSL_VERSION_NUMBER >= 0x10101000L)
     {
         "NO_TLSv1_1", SSL_OP_NO_TLSv1_1
     },
 #else
     { "NO_TLSv1_1", 0 },
 #endif
-#if SSL_OP_NO_TLSv1_2
+#if (OPENSSL_VERSION_NUMBER >= 0x10101000L)
     {
         "NO_TLSv1_2", SSL_OP_NO_TLSv1_2
     },
 #else
     { "NO_TLSv1_2", 0 },
 #endif
-#if SSL_OP_NO_TLSv1_3
+#if (OPENSSL_VERSION_NUMBER >= 0x10101000L)
     {
         "NO_TLSv1_3", SSL_OP_NO_TLSv1_3
     },
 #else
     { "NO_TLSv1_3", 0 },
 #endif
-#if SSL_OP_NO_COMPRESSION
+#if (OPENSSL_VERSION_NUMBER >= 0x10101000L)
     {
         "No_Compression", SSL_OP_NO_COMPRESSION
     },
 #endif
-#if SSL_OP_NO_TICKET
+#if (OPENSSL_VERSION_NUMBER >= 0x10101000L)
     {
         "NO_TICKET", SSL_OP_NO_TICKET
     },
diff --git a/src/security/ServerOptions.cc b/src/security/ServerOptions.cc
index e114ed8..c088d11 100644
--- a/src/security/ServerOptions.cc
+++ b/src/security/ServerOptions.cc
@@ -362,6 +362,10 @@ Security::ServerOptions::loadDhParams()
         return;
     }
 
+#if OPENSSL_VERSION_MAJOR < 3
+    // DH_check() removed in OpenSSL 3.0.
+    // TODO: use the EVP API instead, which also works in OpenSSL 1.1.
+    // But it is not yet clear exactly how that API works for DH.
     int codes;
     if (DH_check(dhp, &codes) == 0) {
         if (codes) {
@@ -370,6 +374,7 @@ Security::ServerOptions::loadDhParams()
             dhp = nullptr;
         }
     }
+#endif
 
     parsedDhParams.resetWithoutLocking(dhp);
 #endif
diff --git a/src/security/ServerOptions.cc.orig b/src/security/ServerOptions.cc.orig
new file mode 100644
index 0000000..e114ed8
--- /dev/null
+++ b/src/security/ServerOptions.cc.orig
@@ -0,0 +1,493 @@
+/*
+ * Copyright (C) 1996-2021 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+#include "squid.h"
+#include "anyp/PortCfg.h"
+#include "base/Packable.h"
+#include "cache_cf.h"
+#include "fatal.h"
+#include "globals.h"
+#include "security/ServerOptions.h"
+#include "security/Session.h"
+#include "SquidConfig.h"
+#if USE_OPENSSL
+#include "compat/openssl.h"
+#include "ssl/support.h"
+
+#if HAVE_OPENSSL_ERR_H
+#include <openssl/err.h>
+#endif
+#endif
+
+Security::ServerOptions &
+Security::ServerOptions::operator =(const Security::ServerOptions &old) {
+    if (this != &old) {
+        Security::PeerOptions::operator =(old);
+        clientCaFile = old.clientCaFile;
+        dh = old.dh;
+        dhParamsFile = old.dhParamsFile;
+        eecdhCurve = old.eecdhCurve;
+        parsedDhParams = old.parsedDhParams;
+#if USE_OPENSSL
+        if (auto *stk = SSL_dup_CA_list(old.clientCaStack.get()))
+            clientCaStack = Security::ServerOptions::X509_NAME_STACK_Pointer(stk);
+        else
+#endif
+            clientCaStack = nullptr;
+
+        staticContextSessionId = old.staticContextSessionId;
+        generateHostCertificates = old.generateHostCertificates;
+        signingCa = old.signingCa;
+        untrustedSigningCa = old.untrustedSigningCa;
+        dynamicCertMemCacheSize = old.dynamicCertMemCacheSize;
+    }
+    return *this;
+}
+
+void
+Security::ServerOptions::parse(const char *token)
+{
+    if (!*token) {
+        // config says just "ssl" or "tls" (or "tls-")
+        encryptTransport = true;
+        return;
+    }
+
+    // parse the server-only options
+    if (strncmp(token, "clientca=", 9) == 0) {
+        clientCaFile = SBuf(token + 9);
+    } else if (strncmp(token, "dh=", 3) == 0) {
+        // clear any previous Diffi-Helman configuration
+        dh.clear();
+        dhParamsFile.clear();
+        eecdhCurve.clear();
+
+        dh.append(token + 3);
+
+        if (!dh.isEmpty()) {
+            auto pos = dh.find(':');
+            if (pos != SBuf::npos) {  // tls-dh=eecdhCurve:dhParamsFile
+                eecdhCurve = dh.substr(0,pos);
+                dhParamsFile = dh.substr(pos+1);
+            } else {  // tls-dh=dhParamsFile
+                dhParamsFile = dh;
+                // empty eecdhCurve means "do not use EECDH"
+            }
+        }
+
+        loadDhParams();
+
+    } else if (strncmp(token, "dhparams=", 9) == 0) {
+        if (!eecdhCurve.isEmpty()) {
+            debugs(83, DBG_PARSE_NOTE(1), "UPGRADE WARNING: EECDH settings in tls-dh= override dhparams=");
+            return;
+        }
+
+        // backward compatibility for dhparams= configuration
+        dh.clear();
+        dh.append(token + 9);
+        dhParamsFile = dh;
+
+        loadDhParams();
+
+    } else if (strncmp(token, "dynamic_cert_mem_cache_size=", 28) == 0) {
+        parseBytesOptionValue(&dynamicCertMemCacheSize, "bytes", token + 28);
+        // XXX: parseBytesOptionValue() self_destruct()s on invalid values,
+        // probably making this comparison and misleading ERROR unnecessary.
+        if (dynamicCertMemCacheSize == std::numeric_limits<size_t>::max()) {
+            debugs(3, DBG_CRITICAL, "ERROR: Cannot allocate memory for '" << token << "'. Using default of 4MB instead.");
+            dynamicCertMemCacheSize = 4*1024*1024; // 4 MB
+        }
+
+    } else if (strcmp(token, "generate-host-certificates") == 0) {
+        generateHostCertificates = true;
+    } else if (strcmp(token, "generate-host-certificates=on") == 0) {
+        generateHostCertificates = true;
+    } else if (strcmp(token, "generate-host-certificates=off") == 0) {
+        generateHostCertificates = false;
+
+    } else if (strncmp(token, "context=", 8) == 0) {
+#if USE_OPENSSL
+        staticContextSessionId = SBuf(token+8);
+        // to hide its arguably sensitive value, do not print token in these debugs
+        if (staticContextSessionId.length() > SSL_MAX_SSL_SESSION_ID_LENGTH) {
+            debugs(83, DBG_CRITICAL, "FATAL: Option 'context=' value is too long. Maximum " << SSL_MAX_SSL_SESSION_ID_LENGTH << " characters.");
+            self_destruct();
+        }
+#else
+        debugs(83, DBG_PARSE_NOTE(DBG_IMPORTANT), "WARNING: Option 'context=' requires --with-openssl. Ignoring.");
+#endif
+
+    } else {
+        // parse generic TLS options
+        Security::PeerOptions::parse(token);
+    }
+}
+
+void
+Security::ServerOptions::dumpCfg(Packable *p, const char *pfx) const
+{
+    // dump out the generic TLS options
+    Security::PeerOptions::dumpCfg(p, pfx);
+
+    if (!encryptTransport)
+        return; // no other settings are relevant
+
+    // dump the server-only options
+    if (!dh.isEmpty())
+        p->appendf(" %sdh=" SQUIDSBUFPH, pfx, SQUIDSBUFPRINT(dh));
+
+    if (!generateHostCertificates)
+        p->appendf(" %sgenerate-host-certificates=off", pfx);
+
+    if (dynamicCertMemCacheSize != 4*1024*1024) // 4MB default, no 'tls-' prefix
+        p->appendf(" dynamic_cert_mem_cache_size=%" PRIuSIZE "bytes", dynamicCertMemCacheSize);
+
+    if (!staticContextSessionId.isEmpty())
+        p->appendf(" %scontext=" SQUIDSBUFPH, pfx, SQUIDSBUFPRINT(staticContextSessionId));
+}
+
+Security::ContextPointer
+Security::ServerOptions::createBlankContext() const
+{
+    Security::ContextPointer ctx;
+#if USE_OPENSSL
+    Ssl::Initialize();
+
+    SSL_CTX *t = SSL_CTX_new(TLS_server_method());
+    if (!t) {
+        const auto x = ERR_get_error();
+        debugs(83, DBG_CRITICAL, "ERROR: Failed to allocate TLS server context: " << Security::ErrorString(x));
+    }
+    ctx = convertContextFromRawPtr(t);
+
+#elif USE_GNUTLS
+    // Initialize for X.509 certificate exchange
+    gnutls_certificate_credentials_t t;
+    if (const int x = gnutls_certificate_allocate_credentials(&t)) {
+        debugs(83, DBG_CRITICAL, "ERROR: Failed to allocate TLS server context: " << Security::ErrorString(x));
+    }
+    ctx = convertContextFromRawPtr(t);
+
+#else
+    debugs(83, DBG_CRITICAL, "ERROR: Failed to allocate TLS server context: No TLS library");
+
+#endif
+
+    return ctx;
+}
+
+void
+Security::ServerOptions::initServerContexts(AnyP::PortCfg &port)
+{
+    const char *portType = AnyP::ProtocolType_str[port.transport.protocol];
+    for (auto &keyData : certs) {
+        keyData.loadFromFiles(port, portType);
+    }
+
+    if (generateHostCertificates) {
+        createSigningContexts(port);
+    }
+
+    if (!certs.empty() && !createStaticServerContext(port)) {
+        char buf[128];
+        fatalf("%s_port %s initialization error", portType, port.s.toUrl(buf, sizeof(buf)));
+    }
+
+    // if generate-host-certificates=off and certs is empty, no contexts may be created.
+    // features depending on contexts do their own checks and error messages later.
+}
+
+bool
+Security::ServerOptions::createStaticServerContext(AnyP::PortCfg &port)
+{
+    updateTlsVersionLimits();
+
+    Security::ContextPointer t(createBlankContext());
+    if (t) {
+
+#if USE_OPENSSL
+        if (certs.size() > 1) {
+            // NOTE: calling SSL_CTX_use_certificate() repeatedly _replaces_ the previous cert details.
+            //       so we cannot use it and support multiple server certificates with OpenSSL.
+            debugs(83, DBG_CRITICAL, "ERROR: OpenSSL does not support multiple server certificates. Ignoring addional cert= parameters.");
+        }
+
+        const auto &keys = certs.front();
+
+        if (!SSL_CTX_use_certificate(t.get(), keys.cert.get())) {
+            const auto x = ERR_get_error();
+            debugs(83, DBG_CRITICAL, "ERROR: Failed to acquire TLS certificate '" << keys.certFile << "': " << Security::ErrorString(x));
+            return false;
+        }
+
+        if (!SSL_CTX_use_PrivateKey(t.get(), keys.pkey.get())) {
+            const auto x = ERR_get_error();
+            debugs(83, DBG_CRITICAL, "ERROR: Failed to acquire TLS private key '" << keys.privateKeyFile << "': " << Security::ErrorString(x));
+            return false;
+        }
+
+        for (auto cert : keys.chain) {
+            if (SSL_CTX_add_extra_chain_cert(t.get(), cert.get())) {
+                // increase the certificate lock
+                X509_up_ref(cert.get());
+            } else {
+                const auto error = ERR_get_error();
+                debugs(83, DBG_IMPORTANT, "WARNING: can not add certificate to SSL context chain: " << Security::ErrorString(error));
+            }
+        }
+
+#elif USE_GNUTLS
+        for (auto &keys : certs) {
+            gnutls_x509_crt_t crt = keys.cert.get();
+            gnutls_x509_privkey_t xkey = keys.pkey.get();
+            const auto x = gnutls_certificate_set_x509_key(t.get(), &crt, 1, xkey);
+            if (x != GNUTLS_E_SUCCESS) {
+                SBuf whichFile = keys.certFile;
+                if (keys.certFile != keys.privateKeyFile) {
+                    whichFile.appendf(" and ");
+                    whichFile.append(keys.privateKeyFile);
+                }
+                debugs(83, DBG_CRITICAL, "ERROR: Failed to initialize server context with keys from " << whichFile << ": " << Security::ErrorString(x));
+                return false;
+            }
+            // XXX: add cert chain to the context
+        }
+#endif
+
+        if (!loadClientCaFile())
+            return false;
+
+        // by this point all config related files must be loaded
+        if (!updateContextConfig(t)) {
+            debugs(83, DBG_CRITICAL, "ERROR: Configuring static TLS context");
+            return false;
+        }
+    }
+
+    staticContext = std::move(t);
+    return bool(staticContext);
+}
+
+void
+Security::ServerOptions::createSigningContexts(const AnyP::PortCfg &port)
+{
+    // For signing we do not have a pre-initialized context object. Instead
+    // contexts are generated as needed. This method initializes the cert
+    // and key pointers used to sign those contexts later.
+
+    signingCa = certs.front();
+
+    const char *portType = AnyP::ProtocolType_str[port.transport.protocol];
+    if (!signingCa.cert) {
+        char buf[128];
+        // XXX: we never actually checked that the cert is capable of signing!
+        fatalf("No valid signing certificate configured for %s_port %s", portType, port.s.toUrl(buf, sizeof(buf)));
+    }
+
+    if (!signingCa.pkey)
+        debugs(3, DBG_IMPORTANT, "No TLS private key configured for  " << portType << "_port " << port.s);
+
+#if USE_OPENSSL
+    Ssl::generateUntrustedCert(untrustedSigningCa.cert, untrustedSigningCa.pkey, signingCa.cert, signingCa.pkey);
+#elif USE_GNUTLS
+    // TODO: implement for GnuTLS. Just a warning for now since generate is implicitly on for all crypto builds.
+    signingCa.cert.reset();
+    signingCa.pkey.reset();
+    debugs(83, DBG_CRITICAL, "WARNING: Dynamic TLS certificate generation requires --with-openssl.");
+    return;
+#else
+    debugs(83, DBG_CRITICAL, "ERROR: Dynamic TLS certificate generation requires --with-openssl.");
+    return;
+#endif
+
+    if (!untrustedSigningCa.cert) {
+        char buf[128];
+        fatalf("Unable to generate signing certificate for untrusted sites for %s_port %s", portType, port.s.toUrl(buf, sizeof(buf)));
+    }
+}
+
+void
+Security::ServerOptions::syncCaFiles()
+{
+    // if caFiles is set, just use that
+    if (caFiles.size())
+        return;
+
+    // otherwise fall back to clientca if it is defined
+    if (!clientCaFile.isEmpty())
+        caFiles.emplace_back(clientCaFile);
+}
+
+/// load clientca= file (if any) into memory.
+/// \retval true   clientca is not set, or loaded successfully
+/// \retval false  unable to load the file, or not using OpenSSL
+bool
+Security::ServerOptions::loadClientCaFile()
+{
+    if (clientCaFile.isEmpty())
+        return true;
+
+#if USE_OPENSSL
+    auto *stk = SSL_load_client_CA_file(clientCaFile.c_str());
+    clientCaStack = Security::ServerOptions::X509_NAME_STACK_Pointer(stk);
+#endif
+    if (!clientCaStack) {
+        debugs(83, DBG_CRITICAL, "FATAL: Unable to read client CAs from file: " << clientCaFile);
+    }
+
+    return bool(clientCaStack);
+}
+
+void
+Security::ServerOptions::loadDhParams()
+{
+    if (dhParamsFile.isEmpty())
+        return;
+
+#if USE_OPENSSL
+    DH *dhp = nullptr;
+    if (FILE *in = fopen(dhParamsFile.c_str(), "r")) {
+        dhp = PEM_read_DHparams(in, NULL, NULL, NULL);
+        fclose(in);
+    }
+
+    if (!dhp) {
+        debugs(83, DBG_IMPORTANT, "WARNING: Failed to read DH parameters '" << dhParamsFile << "'");
+        return;
+    }
+
+    int codes;
+    if (DH_check(dhp, &codes) == 0) {
+        if (codes) {
+            debugs(83, DBG_IMPORTANT, "WARNING: Failed to verify DH parameters '" << dhParamsFile << "' (" << std::hex << codes << ")");
+            DH_free(dhp);
+            dhp = nullptr;
+        }
+    }
+
+    parsedDhParams.resetWithoutLocking(dhp);
+#endif
+}
+
+bool
+Security::ServerOptions::updateContextConfig(Security::ContextPointer &ctx)
+{
+    updateContextOptions(ctx);
+    updateContextSessionId(ctx);
+
+#if USE_OPENSSL
+    if (parsedFlags & SSL_FLAG_NO_SESSION_REUSE) {
+        SSL_CTX_set_session_cache_mode(ctx.get(), SSL_SESS_CACHE_OFF);
+    }
+
+    if (Config.SSL.unclean_shutdown) {
+        debugs(83, 5, "Enabling quiet SSL shutdowns (RFC violation).");
+        SSL_CTX_set_quiet_shutdown(ctx.get(), 1);
+    }
+
+    if (!sslCipher.isEmpty()) {
+        debugs(83, 5, "Using cipher suite " << sslCipher << ".");
+        if (!SSL_CTX_set_cipher_list(ctx.get(), sslCipher.c_str())) {
+            auto ssl_error = ERR_get_error();
+            debugs(83, DBG_CRITICAL, "ERROR: Failed to set SSL cipher suite '" << sslCipher << "': " <<  Security::ErrorString(ssl_error));
+            return false;
+        }
+    }
+
+    Ssl::MaybeSetupRsaCallback(ctx);
+#endif
+
+    updateContextEecdh(ctx);
+    updateContextCa(ctx);
+    updateContextClientCa(ctx);
+
+#if USE_OPENSSL
+    if (parsedFlags & SSL_FLAG_DONT_VERIFY_DOMAIN)
+        SSL_CTX_set_ex_data(ctx.get(), ssl_ctx_ex_index_dont_verify_domain, (void *) -1);
+
+    Security::SetSessionCacheCallbacks(ctx);
+#endif
+    return true;
+}
+
+void
+Security::ServerOptions::updateContextClientCa(Security::ContextPointer &ctx)
+{
+#if USE_OPENSSL
+    if (clientCaStack) {
+        ERR_clear_error();
+        if (STACK_OF(X509_NAME) *clientca = SSL_dup_CA_list(clientCaStack.get())) {
+            SSL_CTX_set_client_CA_list(ctx.get(), clientca);
+        } else {
+            auto ssl_error = ERR_get_error();
+            debugs(83, DBG_CRITICAL, "ERROR: Failed to dupe the client CA list: " << Security::ErrorString(ssl_error));
+            return;
+        }
+
+        Ssl::ConfigurePeerVerification(ctx, parsedFlags);
+
+        updateContextCrl(ctx);
+        updateContextTrust(ctx);
+
+    } else {
+        Ssl::DisablePeerVerification(ctx);
+    }
+#endif
+}
+
+void
+Security::ServerOptions::updateContextEecdh(Security::ContextPointer &ctx)
+{
+    // set Elliptic Curve details into the server context
+    if (!eecdhCurve.isEmpty()) {
+        debugs(83, 9, "Setting Ephemeral ECDH curve to " << eecdhCurve << ".");
+
+#if USE_OPENSSL && OPENSSL_VERSION_NUMBER >= 0x0090800fL && !defined(OPENSSL_NO_ECDH)
+        int nid = OBJ_sn2nid(eecdhCurve.c_str());
+        if (!nid) {
+            debugs(83, DBG_CRITICAL, "ERROR: Unknown EECDH curve '" << eecdhCurve << "'");
+            return;
+        }
+
+        auto ecdh = EC_KEY_new_by_curve_name(nid);
+        if (!ecdh) {
+            const auto x = ERR_get_error();
+            debugs(83, DBG_CRITICAL, "ERROR: Unable to configure Ephemeral ECDH: " << Security::ErrorString(x));
+            return;
+        }
+
+        if (!SSL_CTX_set_tmp_ecdh(ctx.get(), ecdh)) {
+            const auto x = ERR_get_error();
+            debugs(83, DBG_CRITICAL, "ERROR: Unable to set Ephemeral ECDH: " << Security::ErrorString(x));
+        }
+        EC_KEY_free(ecdh);
+
+#else
+        debugs(83, DBG_CRITICAL, "ERROR: EECDH is not available in this build." <<
+               " Please link against OpenSSL>=0.9.8 and ensure OPENSSL_NO_ECDH is not set.");
+#endif
+    }
+
+    // set DH parameters into the server context
+#if USE_OPENSSL
+    if (parsedDhParams) {
+        SSL_CTX_set_tmp_dh(ctx.get(), parsedDhParams.get());
+    }
+#endif
+}
+
+void
+Security::ServerOptions::updateContextSessionId(Security::ContextPointer &ctx)
+{
+#if USE_OPENSSL
+    if (!staticContextSessionId.isEmpty())
+        SSL_CTX_set_session_id_context(ctx.get(), reinterpret_cast<const unsigned char*>(staticContextSessionId.rawContent()), staticContextSessionId.length());
+#endif
+}
+
diff --git a/src/ssl/gadgets.cc b/src/ssl/gadgets.cc
index 88572e5..ee12cb7 100644
--- a/src/ssl/gadgets.cc
+++ b/src/ssl/gadgets.cc
@@ -9,36 +9,26 @@
 #include "squid.h"
 #include "ssl/gadgets.h"
 
-EVP_PKEY * Ssl::createSslPrivateKey()
+static EVP_PKEY *
+CreateRsaPrivateKey()
 {
-    Security::PrivateKeyPointer pkey(EVP_PKEY_new());
-
-    if (!pkey)
-        return NULL;
-
-    BIGNUM_Pointer bn(BN_new());
-    if (!bn)
-        return NULL;
-
-    if (!BN_set_word(bn.get(), RSA_F4))
-        return NULL;
-
-    Ssl::RSA_Pointer rsa(RSA_new());
+    Ssl::EVP_PKEY_CTX_Pointer rsa(EVP_PKEY_CTX_new_id(EVP_PKEY_RSA, nullptr));
     if (!rsa)
-        return NULL;
+        return nullptr;
 
-    int num = 2048; // Maybe use 4096 RSA keys, or better make it configurable?
-    if (!RSA_generate_key_ex(rsa.get(), num, bn.get(), NULL))
-        return NULL;
+    if (EVP_PKEY_keygen_init(rsa.get()) <= 0)
+        return nullptr;
 
-    if (!rsa)
-        return NULL;
+    int num = 2048; // Maybe use 4096 RSA keys, or better make it configurable?
+    if (EVP_PKEY_CTX_set_rsa_keygen_bits(rsa.get(), num) <= 0)
+        return nullptr;
 
-    if (!EVP_PKEY_assign_RSA(pkey.get(), (rsa.get())))
-        return NULL;
+    /* Generate key */
+    EVP_PKEY *pkey = nullptr;
+    if (EVP_PKEY_keygen(rsa.get(), &pkey) <= 0)
+        return nullptr;
 
-    rsa.release();
-    return pkey.release();
+    return pkey;
 }
 
 /**
@@ -551,7 +541,7 @@ static bool generateFakeSslCertificate(Security::CertPointer & certToStore, Secu
     if (properties.signWithPkey.get())
         pkey.resetAndLock(properties.signWithPkey.get());
     else // if not exist generate one
-        pkey.resetWithoutLocking(Ssl::createSslPrivateKey());
+        pkey.resetWithoutLocking(CreateRsaPrivateKey());
 
     if (!pkey)
         return false;
diff --git a/src/ssl/gadgets.h b/src/ssl/gadgets.h
index 4324f81..f3e28aa 100644
--- a/src/ssl/gadgets.h
+++ b/src/ssl/gadgets.h
@@ -57,7 +57,7 @@ typedef std::unique_ptr<TXT_DB, HardFun<void, TXT_DB*, &TXT_DB_free>> TXT_DB_Poi
 
 typedef std::unique_ptr<X509_NAME, HardFun<void, X509_NAME*, &X509_NAME_free>> X509_NAME_Pointer;
 
-typedef std::unique_ptr<RSA, HardFun<void, RSA*, &RSA_free>> RSA_Pointer;
+typedef std::unique_ptr<EVP_PKEY_CTX, HardFun<void, EVP_PKEY_CTX*, &EVP_PKEY_CTX_free>> EVP_PKEY_CTX_Pointer;
 
 typedef std::unique_ptr<X509_REQ, HardFun<void, X509_REQ*, &X509_REQ_free>> X509_REQ_Pointer;
 
@@ -70,12 +70,6 @@ typedef std::unique_ptr<GENERAL_NAME, HardFun<void, GENERAL_NAME*, &GENERAL_NAME
 
 typedef std::unique_ptr<X509_EXTENSION, HardFun<void, X509_EXTENSION*, &X509_EXTENSION_free>> X509_EXTENSION_Pointer;
 
-/**
- \ingroup SslCrtdSslAPI
- * Create 1024 bits rsa key.
- */
-EVP_PKEY * createSslPrivateKey();
-
 /**
  \ingroup SslCrtdSslAPI
  * Write private key and SSL certificate to memory.
diff --git a/src/ssl/support.cc b/src/ssl/support.cc
index df5a212..3ffec33 100644
--- a/src/ssl/support.cc
+++ b/src/ssl/support.cc
@@ -424,7 +424,11 @@ Ssl::DisablePeerVerification(Security::ContextPointer &ctx)
 }
 
 // "dup" function for SSL_get_ex_new_index("cert_err_check")
-#if SQUID_USE_CONST_CRYPTO_EX_DATA_DUP
+#if OPENSSL_VERSION_MAJOR >= 3
+static int
+ssl_dupAclChecklist(CRYPTO_EX_DATA *, const CRYPTO_EX_DATA *, void **,
+                    int, long, void *)
+#elif SQUID_USE_CONST_CRYPTO_EX_DATA_DUP
 static int
 ssl_dupAclChecklist(CRYPTO_EX_DATA *, const CRYPTO_EX_DATA *, void *,
                     int, long, void *)
diff --git a/src/ssl/support.cc.orig b/src/ssl/support.cc.orig
new file mode 100644
index 0000000..df5a212
--- /dev/null
+++ b/src/ssl/support.cc.orig
@@ -0,0 +1,1333 @@
+/*
+ * Copyright (C) 1996-2021 The Squid Software Foundation and contributors
+ *
+ * Squid software is distributed under GPLv2+ license and includes
+ * contributions from numerous individuals and organizations.
+ * Please see the COPYING and CONTRIBUTORS files for details.
+ */
+
+/* DEBUG: section 83    SSL accelerator support */
+
+#include "squid.h"
+
+/* MS Visual Studio Projects are monolithic, so we need the following
+ * #if to exclude the SSL code from compile process when not needed.
+ */
+#if USE_OPENSSL
+
+#include "acl/FilledChecklist.h"
+#include "anyp/PortCfg.h"
+#include "anyp/Uri.h"
+#include "fatal.h"
+#include "fd.h"
+#include "fde.h"
+#include "globals.h"
+#include "ipc/MemMap.h"
+#include "security/CertError.h"
+#include "security/Session.h"
+#include "SquidConfig.h"
+#include "SquidTime.h"
+#include "ssl/bio.h"
+#include "ssl/Config.h"
+#include "ssl/ErrorDetail.h"
+#include "ssl/gadgets.h"
+#include "ssl/support.h"
+
+#include <cerrno>
+
+// TODO: Move ssl_ex_index_* global variables from global.cc here.
+int ssl_ex_index_ssl_untrusted_chain = -1;
+
+static Ssl::CertsIndexedList SquidUntrustedCerts;
+
+const EVP_MD *Ssl::DefaultSignHash = NULL;
+
+std::vector<const char *> Ssl::BumpModeStr = {
+    "none",
+    "client-first",
+    "server-first",
+    "peek",
+    "stare",
+    "bump",
+    "splice",
+    "terminate"
+    /*,"err"*/
+};
+
+/**
+ \defgroup ServerProtocolSSLInternal Server-Side SSL Internals
+ \ingroup ServerProtocolSSLAPI
+ */
+
+int
+Ssl::AskPasswordCb(char *buf, int size, int rwflag, void *userdata)
+{
+    FILE *in;
+    int len = 0;
+    char cmdline[1024];
+
+    snprintf(cmdline, sizeof(cmdline), "\"%s\" \"%s\"", ::Config.Program.ssl_password, (const char *)userdata);
+    in = popen(cmdline, "r");
+
+    if (fgets(buf, size, in))
+
+        len = strlen(buf);
+
+    while (len > 0 && (buf[len - 1] == '\n' || buf[len - 1] == '\r'))
+        --len;
+
+    buf[len] = '\0';
+
+    pclose(in);
+
+    return len;
+}
+
+/// \ingroup ServerProtocolSSLInternal
+static void
+ssl_ask_password(SSL_CTX * context, const char * prompt)
+{
+    if (Config.Program.ssl_password) {
+        SSL_CTX_set_default_passwd_cb(context, Ssl::AskPasswordCb);
+        SSL_CTX_set_default_passwd_cb_userdata(context, (void *)prompt);
+    }
+}
+
+#if HAVE_LIBSSL_SSL_CTX_SET_TMP_RSA_CALLBACK
+static RSA *
+ssl_temp_rsa_cb(SSL * ssl, int anInt, int keylen)
+{
+    static RSA *rsa_512 = nullptr;
+    static RSA *rsa_1024 = nullptr;
+    static BIGNUM *e = nullptr;
+    RSA *rsa = nullptr;
+    int newkey = 0;
+
+    if (!e) {
+        e = BN_new();
+        if (!e || !BN_set_word(e, RSA_F4)) {
+            debugs(83, DBG_IMPORTANT, "ssl_temp_rsa_cb: Failed to set exponent for key " << keylen);
+            BN_free(e);
+            e = nullptr;
+            return nullptr;
+        }
+    }
+
+    switch (keylen) {
+
+    case 512:
+
+        if (!rsa_512) {
+            rsa_512 = RSA_new();
+            if (rsa_512 && RSA_generate_key_ex(rsa_512, 512, e, nullptr)) {
+                newkey = 1;
+            } else {
+                RSA_free(rsa_512);
+                rsa_512 = nullptr;
+            }
+        }
+
+        rsa = rsa_512;
+        break;
+
+    case 1024:
+
+        if (!rsa_1024) {
+            rsa_1024 = RSA_new();
+            if (rsa_1024 && RSA_generate_key_ex(rsa_1024, 1024, e, nullptr)) {
+                newkey = 1;
+            } else {
+                RSA_free(rsa_1024);
+                rsa_1024 = nullptr;
+            }
+        }
+
+        rsa = rsa_1024;
+        break;
+
+    default:
+        debugs(83, DBG_IMPORTANT, "ssl_temp_rsa_cb: Unexpected key length " << keylen);
+        return NULL;
+    }
+
+    if (rsa == NULL) {
+        debugs(83, DBG_IMPORTANT, "ssl_temp_rsa_cb: Failed to generate key " << keylen);
+        return NULL;
+    }
+
+    if (newkey) {
+        if (Debug::Enabled(83, 5))
+            PEM_write_RSAPrivateKey(debug_log, rsa, NULL, NULL, 0, NULL, NULL);
+
+        debugs(83, DBG_IMPORTANT, "Generated ephemeral RSA key of length " << keylen);
+    }
+
+    return rsa;
+}
+#endif
+
+void
+Ssl::MaybeSetupRsaCallback(Security::ContextPointer &ctx)
+{
+#if HAVE_LIBSSL_SSL_CTX_SET_TMP_RSA_CALLBACK
+    debugs(83, 9, "Setting RSA key generation callback.");
+    SSL_CTX_set_tmp_rsa_callback(ctx.get(), ssl_temp_rsa_cb);
+#endif
+}
+
+int Ssl::asn1timeToString(ASN1_TIME *tm, char *buf, int len)
+{
+    BIO *bio;
+    int write = 0;
+    bio = BIO_new(BIO_s_mem());
+    if (bio) {
+        if (ASN1_TIME_print(bio, tm))
+            write = BIO_read(bio, buf, len-1);
+        BIO_free(bio);
+    }
+    buf[write]='\0';
+    return write;
+}
+
+int Ssl::matchX509CommonNames(X509 *peer_cert, void *check_data, int (*check_func)(void *check_data,  ASN1_STRING *cn_data))
+{
+    assert(peer_cert);
+
+    X509_NAME *name = X509_get_subject_name(peer_cert);
+
+    for (int i = X509_NAME_get_index_by_NID(name, NID_commonName, -1); i >= 0; i = X509_NAME_get_index_by_NID(name, NID_commonName, i)) {
+
+        ASN1_STRING *cn_data = X509_NAME_ENTRY_get_data(X509_NAME_get_entry(name, i));
+
+        if ( (*check_func)(check_data, cn_data) == 0)
+            return 1;
+    }
+
+    STACK_OF(GENERAL_NAME) * altnames;
+    altnames = (STACK_OF(GENERAL_NAME)*)X509_get_ext_d2i(peer_cert, NID_subject_alt_name, NULL, NULL);
+
+    if (altnames) {
+        int numalts = sk_GENERAL_NAME_num(altnames);
+        for (int i = 0; i < numalts; ++i) {
+            const GENERAL_NAME *check = sk_GENERAL_NAME_value(altnames, i);
+            if (check->type != GEN_DNS) {
+                continue;
+            }
+            ASN1_STRING *cn_data = check->d.dNSName;
+
+            if ( (*check_func)(check_data, cn_data) == 0) {
+                sk_GENERAL_NAME_pop_free(altnames, GENERAL_NAME_free);
+                return 1;
+            }
+        }
+        sk_GENERAL_NAME_pop_free(altnames, GENERAL_NAME_free);
+    }
+    return 0;
+}
+
+static int check_domain( void *check_data, ASN1_STRING *cn_data)
+{
+    char cn[1024];
+    const char *server = (const char *)check_data;
+
+    if (cn_data->length == 0)
+        return 1; // zero length cn, ignore
+
+    if (cn_data->length > (int)sizeof(cn) - 1)
+        return 1; //if does not fit our buffer just ignore
+
+    char *s = reinterpret_cast<char*>(cn_data->data);
+    char *d = cn;
+    for (int i = 0; i < cn_data->length; ++i, ++d, ++s) {
+        if (*s == '\0')
+            return 1; // always a domain mismatch. contains 0x00
+        *d = *s;
+    }
+    cn[cn_data->length] = '\0';
+    debugs(83, 4, "Verifying server domain " << server << " to certificate name/subjectAltName " << cn);
+    return matchDomainName(server, (cn[0] == '*' ? cn + 1 : cn), mdnRejectSubsubDomains);
+}
+
+bool Ssl::checkX509ServerValidity(X509 *cert, const char *server)
+{
+    return matchX509CommonNames(cert, (void *)server, check_domain);
+}
+
+/// \ingroup ServerProtocolSSLInternal
+static int
+ssl_verify_cb(int ok, X509_STORE_CTX * ctx)
+{
+    // preserve original ctx->error before SSL_ calls can overwrite it
+    Security::ErrorCode error_no = ok ? SSL_ERROR_NONE : X509_STORE_CTX_get_error(ctx);
+
+    char buffer[256] = "";
+    SSL *ssl = (SSL *)X509_STORE_CTX_get_ex_data(ctx, SSL_get_ex_data_X509_STORE_CTX_idx());
+    SSL_CTX *sslctx = SSL_get_SSL_CTX(ssl);
+    SBuf *server = (SBuf *)SSL_get_ex_data(ssl, ssl_ex_index_server);
+    void *dont_verify_domain = SSL_CTX_get_ex_data(sslctx, ssl_ctx_ex_index_dont_verify_domain);
+    ACLChecklist *check = (ACLChecklist*)SSL_get_ex_data(ssl, ssl_ex_index_cert_error_check);
+    X509 *peeked_cert = (X509 *)SSL_get_ex_data(ssl, ssl_ex_index_ssl_peeked_cert);
+    Security::CertPointer peer_cert;
+    peer_cert.resetAndLock(X509_STORE_CTX_get0_cert(ctx));
+
+    X509_NAME_oneline(X509_get_subject_name(peer_cert.get()), buffer, sizeof(buffer));
+
+    // detect infinite loops
+    uint32_t *validationCounter = static_cast<uint32_t *>(SSL_get_ex_data(ssl, ssl_ex_index_ssl_validation_counter));
+    if (!validationCounter) {
+        validationCounter = new uint32_t(1);
+        SSL_set_ex_data(ssl, ssl_ex_index_ssl_validation_counter, validationCounter);
+    } else {
+        // overflows allowed if SQUID_CERT_VALIDATION_ITERATION_MAX >= UINT32_MAX
+        (*validationCounter)++;
+    }
+
+    if ((*validationCounter) >= SQUID_CERT_VALIDATION_ITERATION_MAX) {
+        ok = 0; // or the validation loop will never stop
+        error_no = SQUID_X509_V_ERR_INFINITE_VALIDATION;
+        debugs(83, 2, "SQUID_X509_V_ERR_INFINITE_VALIDATION: " <<
+               *validationCounter << " iterations while checking " << buffer);
+    }
+
+    if (ok) {
+        debugs(83, 5, "SSL Certificate signature OK: " << buffer);
+
+        // Check for domain mismatch only if the current certificate is the peer certificate.
+        if (!dont_verify_domain && server && peer_cert.get() == X509_STORE_CTX_get_current_cert(ctx)) {
+            if (!Ssl::checkX509ServerValidity(peer_cert.get(), server->c_str())) {
+                debugs(83, 2, "SQUID_X509_V_ERR_DOMAIN_MISMATCH: Certificate " << buffer << " does not match domainname " << server);
+                ok = 0;
+                error_no = SQUID_X509_V_ERR_DOMAIN_MISMATCH;
+            }
+        }
+    }
+
+    if (ok && peeked_cert) {
+        // Check whether the already peeked certificate matches the new one.
+        if (X509_cmp(peer_cert.get(), peeked_cert) != 0) {
+            debugs(83, 2, "SQUID_X509_V_ERR_CERT_CHANGE: Certificate " << buffer << " does not match peeked certificate");
+            ok = 0;
+            error_no =  SQUID_X509_V_ERR_CERT_CHANGE;
+        }
+    }
+
+    if (!ok) {
+        Security::CertPointer broken_cert;
+        broken_cert.resetAndLock(X509_STORE_CTX_get_current_cert(ctx));
+        if (!broken_cert)
+            broken_cert = peer_cert;
+
+        Security::CertErrors *errs = static_cast<Security::CertErrors *>(SSL_get_ex_data(ssl, ssl_ex_index_ssl_errors));
+        const int depth = X509_STORE_CTX_get_error_depth(ctx);
+        if (!errs) {
+            errs = new Security::CertErrors(Security::CertError(error_no, broken_cert, depth));
+            if (!SSL_set_ex_data(ssl, ssl_ex_index_ssl_errors,  (void *)errs)) {
+                debugs(83, 2, "Failed to set ssl error_no in ssl_verify_cb: Certificate " << buffer);
+                delete errs;
+                errs = NULL;
+            }
+        } else // remember another error number
+            errs->push_back_unique(Security::CertError(error_no, broken_cert, depth));
+
+        if (const char *err_descr = Ssl::GetErrorDescr(error_no))
+            debugs(83, 5, err_descr << ": " << buffer);
+        else
+            debugs(83, DBG_IMPORTANT, "SSL unknown certificate error " << error_no << " in " << buffer);
+
+        // Check if the certificate error can be bypassed.
+        // Infinity validation loop errors can not bypassed.
+        if (error_no != SQUID_X509_V_ERR_INFINITE_VALIDATION) {
+            if (check) {
+                ACLFilledChecklist *filledCheck = Filled(check);
+                assert(!filledCheck->sslErrors);
+                filledCheck->sslErrors = new Security::CertErrors(Security::CertError(error_no, broken_cert));
+                filledCheck->serverCert = peer_cert;
+                if (check->fastCheck().allowed()) {
+                    debugs(83, 3, "bypassing SSL error " << error_no << " in " << buffer);
+                    ok = 1;
+                } else {
+                    debugs(83, 5, "confirming SSL error " << error_no);
+                }
+                delete filledCheck->sslErrors;
+                filledCheck->sslErrors = NULL;
+                filledCheck->serverCert.reset();
+            }
+            // If the certificate validator is used then we need to allow all errors and
+            // pass them to certficate validator for more processing
+            else if (Ssl::TheConfig.ssl_crt_validator) {
+                ok = 1;
+            }
+        }
+    }
+
+    if (Ssl::TheConfig.ssl_crt_validator) {
+        // Check if we have stored certificates chain. Store if not.
+        if (!SSL_get_ex_data(ssl, ssl_ex_index_ssl_cert_chain)) {
+            STACK_OF(X509) *certStack = X509_STORE_CTX_get1_chain(ctx);
+            if (certStack && !SSL_set_ex_data(ssl, ssl_ex_index_ssl_cert_chain, certStack))
+                sk_X509_pop_free(certStack, X509_free);
+        }
+    }
+
+    if (!ok && !SSL_get_ex_data(ssl, ssl_ex_index_ssl_error_detail) ) {
+
+        // Find the broken certificate. It may be intermediate.
+        Security::CertPointer broken_cert(peer_cert); // reasonable default if search fails
+        // Our SQUID_X509_V_ERR_DOMAIN_MISMATCH implies peer_cert is at fault.
+        if (error_no != SQUID_X509_V_ERR_DOMAIN_MISMATCH) {
+            if (auto *last_used_cert = X509_STORE_CTX_get_current_cert(ctx))
+                broken_cert.resetAndLock(last_used_cert);
+        }
+
+        auto *errDetail = new Ssl::ErrorDetail(error_no, peer_cert.get(), broken_cert.get());
+        if (!SSL_set_ex_data(ssl, ssl_ex_index_ssl_error_detail, errDetail)) {
+            debugs(83, 2, "Failed to set Ssl::ErrorDetail in ssl_verify_cb: Certificate " << buffer);
+            delete errDetail;
+        }
+    }
+
+    return ok;
+}
+
+void
+Ssl::ConfigurePeerVerification(Security::ContextPointer &ctx, const Security::ParsedPortFlags flags)
+{
+    int mode;
+
+    // assume each flag is exclusive; flags creator must check this assumption
+    if (flags & SSL_FLAG_DONT_VERIFY_PEER) {
+        debugs(83, DBG_IMPORTANT, "SECURITY WARNING: Peer certificates are not verified for validity!");
+        debugs(83, DBG_IMPORTANT, "UPGRADE NOTICE: The DONT_VERIFY_PEER flag is deprecated. Remove the clientca= option to disable client certificates.");
+        mode = SSL_VERIFY_NONE;
+    }
+    else if (flags & SSL_FLAG_DELAYED_AUTH) {
+        debugs(83, DBG_PARSE_NOTE(3), "not requesting client certificates until ACL processing requires one");
+        mode = SSL_VERIFY_NONE;
+    }
+    else if (flags & SSL_FLAG_CONDITIONAL_AUTH) {
+        debugs(83, DBG_PARSE_NOTE(3), "will request the client certificate but ignore its absense");
+        mode = SSL_VERIFY_PEER;
+    }
+    else {
+        debugs(83, DBG_PARSE_NOTE(3), "Requiring client certificates.");
+        mode = SSL_VERIFY_PEER|SSL_VERIFY_FAIL_IF_NO_PEER_CERT;
+    }
+
+    SSL_CTX_set_verify(ctx.get(), mode, (mode != SSL_VERIFY_NONE) ? ssl_verify_cb : nullptr);
+}
+
+void
+Ssl::DisablePeerVerification(Security::ContextPointer &ctx)
+{
+    debugs(83, DBG_PARSE_NOTE(3), "Not requiring any client certificates");
+    SSL_CTX_set_verify(ctx.get(),SSL_VERIFY_NONE,nullptr);
+}
+
+// "dup" function for SSL_get_ex_new_index("cert_err_check")
+#if SQUID_USE_CONST_CRYPTO_EX_DATA_DUP
+static int
+ssl_dupAclChecklist(CRYPTO_EX_DATA *, const CRYPTO_EX_DATA *, void *,
+                    int, long, void *)
+#else
+static int
+ssl_dupAclChecklist(CRYPTO_EX_DATA *, CRYPTO_EX_DATA *, void *,
+                    int, long, void *)
+#endif
+{
+    // We do not support duplication of ACLCheckLists.
+    // If duplication is needed, we can count copies with cbdata.
+    assert(false);
+    return 0;
+}
+
+// "free" function for SSL_get_ex_new_index("cert_err_check")
+static void
+ssl_freeAclChecklist(void *, void *ptr, CRYPTO_EX_DATA *,
+                     int, long, void *)
+{
+    delete static_cast<ACLChecklist *>(ptr); // may be NULL
+}
+
+// "free" function for SSL_get_ex_new_index("ssl_error_detail")
+static void
+ssl_free_ErrorDetail(void *, void *ptr, CRYPTO_EX_DATA *,
+                     int, long, void *)
+{
+    Ssl::ErrorDetail  *errDetail = static_cast <Ssl::ErrorDetail *>(ptr);
+    delete errDetail;
+}
+
+static void
+ssl_free_SslErrors(void *, void *ptr, CRYPTO_EX_DATA *,
+                   int, long, void *)
+{
+    Security::CertErrors *errs = static_cast <Security::CertErrors*>(ptr);
+    delete errs;
+}
+
+// "free" function for SSL_get_ex_new_index("ssl_ex_index_ssl_validation_counter")
+static void
+ssl_free_int(void *, void *ptr, CRYPTO_EX_DATA *,
+             int, long, void *)
+{
+    uint32_t *counter = static_cast <uint32_t *>(ptr);
+    delete counter;
+}
+
+/// \ingroup ServerProtocolSSLInternal
+/// Callback handler function to release STACK_OF(X509) "ex" data stored
+/// in an SSL object.
+static void
+ssl_free_CertChain(void *, void *ptr, CRYPTO_EX_DATA *,
+                   int, long, void *)
+{
+    STACK_OF(X509) *certsChain = static_cast <STACK_OF(X509) *>(ptr);
+    sk_X509_pop_free(certsChain,X509_free);
+}
+
+// "free" function for X509 certificates
+static void
+ssl_free_X509(void *, void *ptr, CRYPTO_EX_DATA *,
+              int, long, void *)
+{
+    X509  *cert = static_cast <X509 *>(ptr);
+    X509_free(cert);
+}
+
+// "free" function for SBuf
+static void
+ssl_free_SBuf(void *, void *ptr, CRYPTO_EX_DATA *,
+              int, long, void *)
+{
+    SBuf  *buf = static_cast <SBuf *>(ptr);
+    delete buf;
+}
+
+void
+Ssl::Initialize(void)
+{
+    static bool initialized = false;
+    if (initialized)
+        return;
+    initialized = true;
+
+    SQUID_OPENSSL_init_ssl();
+
+#if !defined(OPENSSL_NO_ENGINE)
+    if (::Config.SSL.ssl_engine) {
+        ENGINE_load_builtin_engines();
+        ENGINE *e;
+        if (!(e = ENGINE_by_id(::Config.SSL.ssl_engine)))
+            fatalf("Unable to find SSL engine '%s'\n", ::Config.SSL.ssl_engine);
+
+        if (!ENGINE_set_default(e, ENGINE_METHOD_ALL)) {
+            const int ssl_error = ERR_get_error();
+            fatalf("Failed to initialise SSL engine: %s\n", Security::ErrorString(ssl_error));
+        }
+    }
+#else
+    if (::Config.SSL.ssl_engine)
+        fatalf("Your OpenSSL has no SSL engine support\n");
+#endif
+
+    const char *defName = ::Config.SSL.certSignHash ? ::Config.SSL.certSignHash : SQUID_SSL_SIGN_HASH_IF_NONE;
+    Ssl::DefaultSignHash = EVP_get_digestbyname(defName);
+    if (!Ssl::DefaultSignHash)
+        fatalf("Sign hash '%s' is not supported\n", defName);
+
+    ssl_ex_index_server = SSL_get_ex_new_index(0, (void *) "server", NULL, NULL, ssl_free_SBuf);
+    ssl_ctx_ex_index_dont_verify_domain = SSL_CTX_get_ex_new_index(0, (void *) "dont_verify_domain", NULL, NULL, NULL);
+    ssl_ex_index_cert_error_check = SSL_get_ex_new_index(0, (void *) "cert_error_check", NULL, &ssl_dupAclChecklist, &ssl_freeAclChecklist);
+    ssl_ex_index_ssl_error_detail = SSL_get_ex_new_index(0, (void *) "ssl_error_detail", NULL, NULL, &ssl_free_ErrorDetail);
+    ssl_ex_index_ssl_peeked_cert  = SSL_get_ex_new_index(0, (void *) "ssl_peeked_cert", NULL, NULL, &ssl_free_X509);
+    ssl_ex_index_ssl_errors =  SSL_get_ex_new_index(0, (void *) "ssl_errors", NULL, NULL, &ssl_free_SslErrors);
+    ssl_ex_index_ssl_cert_chain = SSL_get_ex_new_index(0, (void *) "ssl_cert_chain", NULL, NULL, &ssl_free_CertChain);
+    ssl_ex_index_ssl_validation_counter = SSL_get_ex_new_index(0, (void *) "ssl_validation_counter", NULL, NULL, &ssl_free_int);
+    ssl_ex_index_ssl_untrusted_chain = SSL_get_ex_new_index(0, (void *) "ssl_untrusted_chain", NULL, NULL, &ssl_free_CertChain);
+}
+
+bool
+Ssl::InitServerContext(Security::ContextPointer &ctx, AnyP::PortCfg &port)
+{
+    if (!ctx)
+        return false;
+
+    return true;
+}
+
+bool
+Ssl::InitClientContext(Security::ContextPointer &ctx, Security::PeerOptions &peer, Security::ParsedPortFlags fl)
+{
+    if (!ctx)
+        return false;
+
+    if (!peer.sslCipher.isEmpty()) {
+        debugs(83, 5, "Using chiper suite " << peer.sslCipher << ".");
+
+        const char *cipher = peer.sslCipher.c_str();
+        if (!SSL_CTX_set_cipher_list(ctx.get(), cipher)) {
+            const int ssl_error = ERR_get_error();
+            fatalf("Failed to set SSL cipher suite '%s': %s\n",
+                   cipher, Security::ErrorString(ssl_error));
+        }
+    }
+
+    if (!peer.certs.empty()) {
+        // TODO: support loading multiple cert/key pairs
+        auto &keys = peer.certs.front();
+        if (!keys.certFile.isEmpty()) {
+            debugs(83, DBG_IMPORTANT, "Using certificate in " << keys.certFile);
+
+            const char *certfile = keys.certFile.c_str();
+            if (!SSL_CTX_use_certificate_chain_file(ctx.get(), certfile)) {
+                const int ssl_error = ERR_get_error();
+                fatalf("Failed to acquire SSL certificate '%s': %s\n",
+                       certfile, Security::ErrorString(ssl_error));
+            }
+
+            debugs(83, DBG_IMPORTANT, "Using private key in " << keys.privateKeyFile);
+            const char *keyfile = keys.privateKeyFile.c_str();
+            ssl_ask_password(ctx.get(), keyfile);
+
+            if (!SSL_CTX_use_PrivateKey_file(ctx.get(), keyfile, SSL_FILETYPE_PEM)) {
+                const int ssl_error = ERR_get_error();
+                fatalf("Failed to acquire SSL private key '%s': %s\n",
+                       keyfile, Security::ErrorString(ssl_error));
+            }
+
+            debugs(83, 5, "Comparing private and public SSL keys.");
+
+            if (!SSL_CTX_check_private_key(ctx.get())) {
+                const int ssl_error = ERR_get_error();
+                fatalf("SSL private key '%s' does not match public key '%s': %s\n",
+                       certfile, keyfile, Security::ErrorString(ssl_error));
+            }
+        }
+    }
+
+    MaybeSetupRsaCallback(ctx);
+
+    Ssl::ConfigurePeerVerification(ctx, fl);
+
+    return true;
+}
+
+/// \ingroup ServerProtocolSSLInternal
+static const char *
+ssl_get_attribute(X509_NAME * name, const char *attribute_name)
+{
+    static char buffer[1024];
+    buffer[0] = '\0';
+
+    if (strcmp(attribute_name, "DN") == 0) {
+        X509_NAME_oneline(name, buffer, sizeof(buffer));
+    } else {
+        int nid = OBJ_txt2nid(const_cast<char *>(attribute_name));
+        if (nid == 0) {
+            debugs(83, DBG_IMPORTANT, "WARNING: Unknown SSL attribute name '" << attribute_name << "'");
+            return nullptr;
+        }
+        X509_NAME_get_text_by_NID(name, nid, buffer, sizeof(buffer));
+    }
+
+    return *buffer ? buffer : nullptr;
+}
+
+/// \ingroup ServerProtocolSSLInternal
+const char *
+Ssl::GetX509UserAttribute(X509 * cert, const char *attribute_name)
+{
+    X509_NAME *name;
+    const char *ret;
+
+    if (!cert)
+        return NULL;
+
+    name = X509_get_subject_name(cert);
+
+    ret = ssl_get_attribute(name, attribute_name);
+
+    return ret;
+}
+
+const char *
+Ssl::GetX509Fingerprint(X509 * cert, const char *)
+{
+    static char buf[1024];
+    if (!cert)
+        return NULL;
+
+    unsigned int n;
+    unsigned char md[EVP_MAX_MD_SIZE];
+    if (!X509_digest(cert, EVP_sha1(), md, &n))
+        return NULL;
+
+    assert(3 * n + 1 < sizeof(buf));
+
+    char *s = buf;
+    for (unsigned int i=0; i < n; ++i, s += 3) {
+        const char term = (i + 1 < n) ? ':' : '\0';
+        snprintf(s, 4, "%02X%c", md[i], term);
+    }
+
+    return buf;
+}
+
+SBuf
+Ssl::GetX509PEM(X509 * cert)
+{
+    assert(cert);
+
+    Ssl::BIO_Pointer bio(BIO_new(BIO_s_mem()));
+    PEM_write_bio_X509(bio.get(), cert);
+
+    char *ptr;
+    const auto len = BIO_get_mem_data(bio.get(), &ptr);
+    return SBuf(ptr, len);
+}
+
+/// \ingroup ServerProtocolSSLInternal
+const char *
+Ssl::GetX509CAAttribute(X509 * cert, const char *attribute_name)
+{
+
+    X509_NAME *name;
+    const char *ret;
+
+    if (!cert)
+        return NULL;
+
+    name = X509_get_issuer_name(cert);
+
+    ret = ssl_get_attribute(name, attribute_name);
+
+    return ret;
+}
+
+const char *sslGetUserAttribute(SSL *ssl, const char *attribute_name)
+{
+    if (!ssl)
+        return NULL;
+
+    X509 *cert = SSL_get_peer_certificate(ssl);
+
+    const char *attr = Ssl::GetX509UserAttribute(cert, attribute_name);
+
+    X509_free(cert);
+    return attr;
+}
+
+const char *sslGetCAAttribute(SSL *ssl, const char *attribute_name)
+{
+    if (!ssl)
+        return NULL;
+
+    X509 *cert = SSL_get_peer_certificate(ssl);
+
+    const char *attr = Ssl::GetX509CAAttribute(cert, attribute_name);
+
+    X509_free(cert);
+    return attr;
+}
+
+const char *
+sslGetUserEmail(SSL * ssl)
+{
+    return sslGetUserAttribute(ssl, "emailAddress");
+}
+
+SBuf
+sslGetUserCertificatePEM(SSL *ssl)
+{
+    assert(ssl);
+
+    if (const auto cert = SSL_get_peer_certificate(ssl))
+        return Ssl::GetX509PEM(cert);
+
+    return SBuf();
+}
+
+SBuf
+sslGetUserCertificateChainPEM(SSL *ssl)
+{
+    assert(ssl);
+
+    auto chain = SSL_get_peer_cert_chain(ssl);
+
+    if (!chain)
+        return sslGetUserCertificatePEM(ssl);
+
+    Ssl::BIO_Pointer bio(BIO_new(BIO_s_mem()));
+
+    for (int i = 0; i < sk_X509_num(chain); ++i) {
+        X509 *cert = sk_X509_value(chain, i);
+        PEM_write_bio_X509(bio.get(), cert);
+    }
+
+    char *ptr;
+    const auto len = BIO_get_mem_data(bio.get(), &ptr);
+    return SBuf(ptr, len);
+}
+
+/// Create SSL context and apply ssl certificate and private key to it.
+Security::ContextPointer
+Ssl::createSSLContext(Security::CertPointer & x509, Security::PrivateKeyPointer & pkey, Security::ServerOptions &options)
+{
+    Security::ContextPointer ctx(options.createBlankContext());
+
+    if (!SSL_CTX_use_certificate(ctx.get(), x509.get()))
+        return Security::ContextPointer();
+
+    if (!SSL_CTX_use_PrivateKey(ctx.get(), pkey.get()))
+        return Security::ContextPointer();
+
+    if (!options.updateContextConfig(ctx))
+        return Security::ContextPointer();
+
+    return ctx;
+}
+
+Security::ContextPointer
+Ssl::GenerateSslContextUsingPkeyAndCertFromMemory(const char * data, Security::ServerOptions &options, bool trusted)
+{
+    Security::CertPointer cert;
+    Security::PrivateKeyPointer pkey;
+    if (!readCertAndPrivateKeyFromMemory(cert, pkey, data) || !cert || !pkey)
+        return Security::ContextPointer();
+
+    Security::ContextPointer ctx(createSSLContext(cert, pkey, options));
+    if (ctx && trusted)
+        Ssl::chainCertificatesToSSLContext(ctx, options);
+    return ctx;
+}
+
+Security::ContextPointer
+Ssl::GenerateSslContext(CertificateProperties const &properties, Security::ServerOptions &options, bool trusted)
+{
+    Security::CertPointer cert;
+    Security::PrivateKeyPointer pkey;
+    if (!generateSslCertificate(cert, pkey, properties) || !cert || !pkey)
+        return Security::ContextPointer();
+
+    Security::ContextPointer ctx(createSSLContext(cert, pkey, options));
+    if (ctx && trusted)
+        Ssl::chainCertificatesToSSLContext(ctx, options);
+    return ctx;
+}
+
+void
+Ssl::chainCertificatesToSSLContext(Security::ContextPointer &ctx, Security::ServerOptions &options)
+{
+    assert(ctx);
+    // Add signing certificate to the certificates chain
+    X509 *signingCert = options.signingCa.cert.get();
+    if (SSL_CTX_add_extra_chain_cert(ctx.get(), signingCert)) {
+        // increase the certificate lock
+        X509_up_ref(signingCert);
+    } else {
+        const int ssl_error = ERR_get_error();
+        debugs(33, DBG_IMPORTANT, "WARNING: can not add signing certificate to SSL context chain: " << Security::ErrorString(ssl_error));
+    }
+
+    for (auto cert : options.signingCa.chain) {
+        if (SSL_CTX_add_extra_chain_cert(ctx.get(), cert.get())) {
+            // increase the certificate lock
+            X509_up_ref(cert.get());
+        } else {
+            const auto error = ERR_get_error();
+            debugs(83, DBG_IMPORTANT, "WARNING: can not add certificate to SSL dynamic context chain: " << Security::ErrorString(error));
+        }
+    }
+}
+
+void
+Ssl::configureUnconfiguredSslContext(Security::ContextPointer &ctx, Ssl::CertSignAlgorithm signAlgorithm,AnyP::PortCfg &port)
+{
+    if (ctx && signAlgorithm == Ssl::algSignTrusted)
+        Ssl::chainCertificatesToSSLContext(ctx, port.secure);
+}
+
+bool
+Ssl::configureSSL(SSL *ssl, CertificateProperties const &properties, AnyP::PortCfg &port)
+{
+    Security::CertPointer cert;
+    Security::PrivateKeyPointer pkey;
+    if (!generateSslCertificate(cert, pkey, properties))
+        return false;
+
+    if (!cert)
+        return false;
+
+    if (!pkey)
+        return false;
+
+    if (!SSL_use_certificate(ssl, cert.get()))
+        return false;
+
+    if (!SSL_use_PrivateKey(ssl, pkey.get()))
+        return false;
+
+    return true;
+}
+
+bool
+Ssl::configureSSLUsingPkeyAndCertFromMemory(SSL *ssl, const char *data, AnyP::PortCfg &port)
+{
+    Security::CertPointer cert;
+    Security::PrivateKeyPointer pkey;
+    if (!readCertAndPrivateKeyFromMemory(cert, pkey, data))
+        return false;
+
+    if (!cert || !pkey)
+        return false;
+
+    if (!SSL_use_certificate(ssl, cert.get()))
+        return false;
+
+    if (!SSL_use_PrivateKey(ssl, pkey.get()))
+        return false;
+
+    return true;
+}
+
+bool
+Ssl::verifySslCertificate(Security::ContextPointer &ctx, CertificateProperties const &properties)
+{
+#if HAVE_SSL_CTX_GET0_CERTIFICATE
+    X509 * cert = SSL_CTX_get0_certificate(ctx.get());
+#elif SQUID_USE_SSLGETCERTIFICATE_HACK
+    // SSL_get_certificate is buggy in openssl versions 1.0.1d and 1.0.1e
+    // Try to retrieve certificate directly from Security::ContextPointer object
+    X509 ***pCert = (X509 ***)ctx->cert;
+    X509 * cert = pCert && *pCert ? **pCert : NULL;
+#elif SQUID_SSLGETCERTIFICATE_BUGGY
+    X509 * cert = NULL;
+    assert(0);
+#else
+    // Temporary ssl for getting X509 certificate from SSL_CTX.
+    Security::SessionPointer ssl(Security::NewSessionObject(ctx));
+    X509 * cert = SSL_get_certificate(ssl.get());
+#endif
+    if (!cert)
+        return false;
+    const auto time_notBefore = X509_getm_notBefore(cert);
+    const auto time_notAfter = X509_getm_notAfter(cert);
+    return (X509_cmp_current_time(time_notBefore) < 0 && X509_cmp_current_time(time_notAfter) > 0);
+}
+
+void
+Ssl::setClientSNI(SSL *ssl, const char *fqdn)
+{
+    const Ip::Address test(fqdn);
+    if (!test.isAnyAddr())
+        return; // raw IP is inappropriate for SNI
+
+    //The SSL_CTRL_SET_TLSEXT_HOSTNAME is a openssl macro which indicates
+    // if the TLS servername extension (SNI) is enabled in openssl library.
+#if defined(SSL_CTRL_SET_TLSEXT_HOSTNAME)
+    if (!SSL_set_tlsext_host_name(ssl, fqdn)) {
+        const int ssl_error = ERR_get_error();
+        debugs(83, 3,  "WARNING: unable to set TLS servername extension (SNI): " <<
+               Security::ErrorString(ssl_error) << "\n");
+    }
+#else
+    debugs(83, 7,  "no support for TLS servername extension (SNI)");
+#endif
+}
+
+static const char *
+hasAuthorityInfoAccessCaIssuers(X509 *cert)
+{
+    AUTHORITY_INFO_ACCESS *info;
+    if (!cert)
+        return nullptr;
+    info = static_cast<AUTHORITY_INFO_ACCESS *>(X509_get_ext_d2i(cert, NID_info_access, NULL, NULL));
+    if (!info)
+        return nullptr;
+
+    static char uri[MAX_URL];
+    uri[0] = '\0';
+
+    for (int i = 0; i < sk_ACCESS_DESCRIPTION_num(info); i++) {
+        ACCESS_DESCRIPTION *ad = sk_ACCESS_DESCRIPTION_value(info, i);
+        if (OBJ_obj2nid(ad->method) == NID_ad_ca_issuers) {
+            if (ad->location->type == GEN_URI) {
+                xstrncpy(uri,
+                         reinterpret_cast<const char *>(
+                             ASN1_STRING_get0_data(ad->location->d.uniformResourceIdentifier)
+                         ),
+                         sizeof(uri));
+            }
+            break;
+        }
+    }
+    AUTHORITY_INFO_ACCESS_free(info);
+    return uri[0] != '\0' ? uri : nullptr;
+}
+
+bool
+Ssl::loadCerts(const char *certsFile, Ssl::CertsIndexedList &list)
+{
+    BIO *in = BIO_new_file(certsFile, "r");
+    if (!in) {
+        debugs(83, DBG_IMPORTANT, "Failed to open '" << certsFile << "' to load certificates");
+        return false;
+    }
+
+    X509 *aCert;
+    while((aCert = PEM_read_bio_X509(in, NULL, NULL, NULL))) {
+        static char buffer[2048];
+        X509_NAME_oneline(X509_get_subject_name(aCert), buffer, sizeof(buffer));
+        list.insert(std::pair<SBuf, X509 *>(SBuf(buffer), aCert));
+    }
+    debugs(83, 4, "Loaded " << list.size() << " certificates from file: '" << certsFile << "'");
+    BIO_free(in);
+    return true;
+}
+
+/// quickly find the issuer certificate of a certificate cert in the
+/// Ssl::CertsIndexedList list
+static X509 *
+findCertIssuerFast(Ssl::CertsIndexedList &list, X509 *cert)
+{
+    static char buffer[2048];
+
+    if (X509_NAME *issuerName = X509_get_issuer_name(cert))
+        X509_NAME_oneline(issuerName, buffer, sizeof(buffer));
+    else
+        return NULL;
+
+    const auto ret = list.equal_range(SBuf(buffer));
+    for (Ssl::CertsIndexedList::iterator it = ret.first; it != ret.second; ++it) {
+        X509 *issuer = it->second;
+        if (X509_check_issued(issuer, cert) == X509_V_OK) {
+            return issuer;
+        }
+    }
+    return NULL;
+}
+
+/// slowly find the issuer certificate of a given cert using linear search
+static bool
+findCertIssuer(Security::CertList const &list, X509 *cert)
+{
+    for (Security::CertList::const_iterator it = list.begin(); it != list.end(); ++it) {
+        if (X509_check_issued(it->get(), cert) == X509_V_OK)
+            return true;
+    }
+    return false;
+}
+
+/// \return true if the cert issuer exist in the certificates stored in connContext
+static bool
+issuerExistInCaDb(X509 *cert, const Security::ContextPointer &connContext)
+{
+    if (!connContext)
+        return false;
+
+    X509_STORE_CTX *storeCtx = X509_STORE_CTX_new();
+    if (!storeCtx) {
+        debugs(83, DBG_IMPORTANT, "Failed to allocate STORE_CTX object");
+        return false;
+    }
+
+    bool gotIssuer = false;
+    X509_STORE *store = SSL_CTX_get_cert_store(connContext.get());
+    if (X509_STORE_CTX_init(storeCtx, store, nullptr, nullptr)) {
+        X509 *issuer = nullptr;
+        gotIssuer = (X509_STORE_CTX_get1_issuer(&issuer, storeCtx, cert) > 0);
+        if (issuer)
+            X509_free(issuer);
+    } else {
+        const int ssl_error = ERR_get_error();
+        debugs(83, DBG_IMPORTANT, "Failed to initialize STORE_CTX object: " << Security::ErrorString(ssl_error));
+    }
+    X509_STORE_CTX_free(storeCtx);
+
+    return gotIssuer;
+}
+
+const char *
+Ssl::uriOfIssuerIfMissing(X509 *cert, Security::CertList const &serverCertificates, const Security::ContextPointer &context)
+{
+    if (!cert || !serverCertificates.size())
+        return nullptr;
+
+    if (!findCertIssuer(serverCertificates, cert)) {
+        //if issuer is missing
+        if (const char *issuerUri = hasAuthorityInfoAccessCaIssuers(cert)) {
+            // There is a URI where we can download a certificate.
+            if (!findCertIssuerFast(SquidUntrustedCerts, cert) &&
+                    !issuerExistInCaDb(cert, context)) {
+                // and issuer not found in local databases containing
+                // untrusted certificates and trusted CA certificates
+                return issuerUri;
+            }
+        }
+    }
+    return nullptr;
+}
+
+void
+Ssl::missingChainCertificatesUrls(std::queue<SBuf> &URIs, Security::CertList const &serverCertificates, const Security::ContextPointer &context)
+{
+    if (!serverCertificates.size())
+        return;
+
+    for (const auto &i : serverCertificates) {
+        if (const char *issuerUri = uriOfIssuerIfMissing(i.get(), serverCertificates, context))
+            URIs.push(SBuf(issuerUri));
+    }
+}
+
+void
+Ssl::SSL_add_untrusted_cert(SSL *ssl, X509 *cert)
+{
+    STACK_OF(X509) *untrustedStack = static_cast <STACK_OF(X509) *>(SSL_get_ex_data(ssl, ssl_ex_index_ssl_untrusted_chain));
+    if (!untrustedStack) {
+        untrustedStack = sk_X509_new_null();
+        if (!SSL_set_ex_data(ssl, ssl_ex_index_ssl_untrusted_chain, untrustedStack)) {
+            sk_X509_pop_free(untrustedStack, X509_free);
+            throw TextException("Failed to attach untrusted certificates chain", Here());
+        }
+    }
+    sk_X509_push(untrustedStack, cert);
+}
+
+/// Search for the issuer certificate of cert in sk list.
+static X509 *
+sk_x509_findIssuer(STACK_OF(X509) *sk, X509 *cert)
+{
+    if (!sk)
+        return NULL;
+
+    const int skItemsNum = sk_X509_num(sk);
+    for (int i = 0; i < skItemsNum; ++i) {
+        X509 *issuer = sk_X509_value(sk, i);
+        if (X509_check_issued(issuer, cert) == X509_V_OK)
+            return issuer;
+    }
+    return NULL;
+}
+
+/// add missing issuer certificates to untrustedCerts
+static void
+completeIssuers(X509_STORE_CTX *ctx, STACK_OF(X509) *untrustedCerts)
+{
+    debugs(83, 2,  "completing " << sk_X509_num(untrustedCerts) << " OpenSSL untrusted certs using " << SquidUntrustedCerts.size() << " configured untrusted certificates");
+
+    const X509_VERIFY_PARAM *param = X509_STORE_CTX_get0_param(ctx);
+    int depth = X509_VERIFY_PARAM_get_depth(param);
+    X509 *current = X509_STORE_CTX_get0_cert(ctx);
+    int i = 0;
+    for (i = 0; current && (i < depth); ++i) {
+        if (X509_check_issued(current, current) == X509_V_OK) {
+            // either ctx->cert is itself self-signed or untrustedCerts
+            // aready contain the self-signed current certificate
+            break;
+        }
+
+        // untrustedCerts is short, not worth indexing
+        X509 *issuer = sk_x509_findIssuer(untrustedCerts, current);
+        if (!issuer) {
+            if ((issuer = findCertIssuerFast(SquidUntrustedCerts, current)))
+                sk_X509_push(untrustedCerts, issuer);
+        }
+        current = issuer;
+    }
+
+    if (i >= depth)
+        debugs(83, 2,  "exceeded the maximum certificate chain length: " << depth);
+}
+
+/// OpenSSL certificate validation callback.
+static int
+untrustedToStoreCtx_cb(X509_STORE_CTX *ctx,void *data)
+{
+    debugs(83, 4,  "Try to use pre-downloaded intermediate certificates");
+
+    SSL *ssl = static_cast<SSL *>(X509_STORE_CTX_get_ex_data(ctx, SSL_get_ex_data_X509_STORE_CTX_idx()));
+    STACK_OF(X509) *sslUntrustedStack = static_cast <STACK_OF(X509) *>(SSL_get_ex_data(ssl, ssl_ex_index_ssl_untrusted_chain));
+
+    // OpenSSL already maintains ctx->untrusted but we cannot modify
+    // internal OpenSSL list directly. We have to give OpenSSL our own
+    // list, but it must include certificates on the OpenSSL ctx->untrusted
+    STACK_OF(X509) *oldUntrusted = X509_STORE_CTX_get0_untrusted(ctx);
+    STACK_OF(X509) *sk = sk_X509_dup(oldUntrusted); // oldUntrusted is always not NULL
+
+    for (int i = 0; i < sk_X509_num(sslUntrustedStack); ++i) {
+        X509 *cert = sk_X509_value(sslUntrustedStack, i);
+        sk_X509_push(sk, cert);
+    }
+
+    // If the local untrusted certificates internal database is used
+    // run completeIssuers to add missing certificates if possible.
+    if (SquidUntrustedCerts.size() > 0)
+        completeIssuers(ctx, sk);
+
+    X509_STORE_CTX_set0_untrusted(ctx, sk); // No locking/unlocking, just sets ctx->untrusted
+    int ret = X509_verify_cert(ctx);
+    X509_STORE_CTX_set0_untrusted(ctx, oldUntrusted); // Set back the old untrusted list
+    sk_X509_free(sk); // Release sk list
+    return ret;
+}
+
+void
+Ssl::useSquidUntrusted(SSL_CTX *sslContext)
+{
+    SSL_CTX_set_cert_verify_callback(sslContext, untrustedToStoreCtx_cb, NULL);
+}
+
+bool
+Ssl::loadSquidUntrusted(const char *path)
+{
+    return Ssl::loadCerts(path, SquidUntrustedCerts);
+}
+
+void
+Ssl::unloadSquidUntrusted()
+{
+    if (SquidUntrustedCerts.size()) {
+        for (Ssl::CertsIndexedList::iterator it = SquidUntrustedCerts.begin(); it != SquidUntrustedCerts.end(); ++it) {
+            X509_free(it->second);
+        }
+        SquidUntrustedCerts.clear();
+    }
+}
+
+bool Ssl::generateUntrustedCert(Security::CertPointer &untrustedCert, Security::PrivateKeyPointer &untrustedPkey, Security::CertPointer const  &cert, Security::PrivateKeyPointer const & pkey)
+{
+    // Generate the self-signed certificate, using a hard-coded subject prefix
+    Ssl::CertificateProperties certProperties;
+    if (const char *cn = CommonHostName(cert.get())) {
+        certProperties.commonName = "Not trusted by \"";
+        certProperties.commonName += cn;
+        certProperties.commonName += "\"";
+    } else if (const char *org = getOrganization(cert.get())) {
+        certProperties.commonName =  "Not trusted by \"";
+        certProperties.commonName += org;
+        certProperties.commonName += "\"";
+    } else
+        certProperties.commonName =  "Not trusted";
+    certProperties.setCommonName = true;
+    // O, OU, and other CA subject fields will be mimicked
+    // Expiration date and other common properties will be mimicked
+    certProperties.signAlgorithm = Ssl::algSignSelf;
+    certProperties.signWithPkey.resetAndLock(pkey.get());
+    certProperties.mimicCert.resetAndLock(cert.get());
+    return Ssl::generateSslCertificate(untrustedCert, untrustedPkey, certProperties);
+}
+
+void Ssl::InRamCertificateDbKey(const Ssl::CertificateProperties &certProperties, SBuf &key)
+{
+    bool origSignatureAsKey = false;
+    if (certProperties.mimicCert) {
+        if (auto *sig = Ssl::X509_get_signature(certProperties.mimicCert)) {
+            origSignatureAsKey = true;
+            key.append((const char *)sig->data, sig->length);
+        }
+    }
+
+    if (!origSignatureAsKey || certProperties.setCommonName) {
+        // Use common name instead
+        key.append(certProperties.commonName.c_str());
+    }
+    key.append(certProperties.setCommonName ? '1' : '0');
+    key.append(certProperties.setValidAfter ? '1' : '0');
+    key.append(certProperties.setValidBefore ? '1' : '0');
+    key.append(certProperties.signAlgorithm != Ssl:: algSignEnd ? certSignAlgorithm(certProperties.signAlgorithm) : "-");
+    key.append(certProperties.signHash ? EVP_MD_name(certProperties.signHash) : "-");
+
+    if (certProperties.mimicCert) {
+        Ssl::BIO_Pointer bio(BIO_new_SBuf(&key));
+        ASN1_item_i2d_bio(ASN1_ITEM_rptr(X509), bio.get(), (ASN1_VALUE *)certProperties.mimicCert.get());
+    }
+}
+
+static int
+bio_sbuf_create(BIO* bio)
+{
+    BIO_set_init(bio, 0);
+    BIO_set_data(bio, NULL);
+    return 1;
+}
+
+static int
+bio_sbuf_destroy(BIO* bio)
+{
+    if (!bio)
+        return 0;
+    return 1;
+}
+
+int
+bio_sbuf_write(BIO* bio, const char* data, int len)
+{
+    SBuf *buf = static_cast<SBuf *>(BIO_get_data(bio));
+    // TODO: Convert exceptions into BIO errors
+    buf->append(data, len);
+    return len;
+}
+
+int
+bio_sbuf_puts(BIO* bio, const char* data)
+{
+    // TODO: use bio_sbuf_write() instead
+    SBuf *buf = static_cast<SBuf *>(BIO_get_data(bio));
+    size_t oldLen = buf->length();
+    buf->append(data);
+    return buf->length() - oldLen;
+}
+
+long
+bio_sbuf_ctrl(BIO* bio, int cmd, long num, void* ptr) {
+    SBuf *buf = static_cast<SBuf *>(BIO_get_data(bio));
+    switch (cmd) {
+    case BIO_CTRL_RESET:
+        // TODO: Convert exceptions into BIO errors
+        buf->clear();
+        return 1;
+    case BIO_CTRL_FLUSH:
+        return 1;
+    default:
+        return 0;
+    }
+}
+
+BIO *Ssl::BIO_new_SBuf(SBuf *buf)
+{
+#if HAVE_LIBCRYPTO_BIO_METH_NEW
+    static BIO_METHOD *BioSBufMethods = nullptr;
+    if (!BioSBufMethods) {
+        BioSBufMethods = BIO_meth_new(BIO_TYPE_MEM, "Squid-SBuf");
+        BIO_meth_set_write(BioSBufMethods, bio_sbuf_write);
+        BIO_meth_set_read(BioSBufMethods, nullptr);
+        BIO_meth_set_puts(BioSBufMethods, bio_sbuf_puts);
+        BIO_meth_set_gets(BioSBufMethods, nullptr);
+        BIO_meth_set_ctrl(BioSBufMethods, bio_sbuf_ctrl);
+        BIO_meth_set_create(BioSBufMethods, bio_sbuf_create);
+        BIO_meth_set_destroy(BioSBufMethods, bio_sbuf_destroy);
+    }
+#else
+    static BIO_METHOD *BioSBufMethods = new BIO_METHOD({
+        BIO_TYPE_MEM,
+        "Squid SBuf",
+        bio_sbuf_write,
+        nullptr,
+        bio_sbuf_puts,
+        nullptr,
+        bio_sbuf_ctrl,
+        bio_sbuf_create,
+        bio_sbuf_destroy,
+        NULL
+    });
+#endif
+    BIO *bio = BIO_new(BioSBufMethods);
+    Must(bio);
+    BIO_set_data(bio, buf);
+    BIO_set_init(bio, 1);
+    return bio;
+}
+
+#endif /* USE_OPENSSL */
+
-- 
2.17.1

